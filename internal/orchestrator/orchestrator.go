// internal/orchestrator/orchestrator.go
//
// The orchestrator handles:
// 1. Spawning a new tmux window for OpenCode
// 2. Running OpenCode with the right arguments to call your MCP server
// 3. Monitoring when OpenCode finishes
// 4. Killing the window and reporting back
//
// This uses bubbletea's command pattern - we return tea.Cmd functions
// that run async and send messages back when done.

package orchestrator

import (
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/yourusername/lattice/internal/community"
	"github.com/yourusername/lattice/internal/config"
	"github.com/yourusername/lattice/internal/skills"
)

// Agent represents a denizen CV
type Agent struct {
	Name       string `json:"name"`
	Community  string `json:"community"`
	Byline     string `json:"byline"`
	Precision  int    `json:"precision"`
	Autonomy   int    `json:"autonomy"`
	Experience int    `json:"experience"`
	Summary    string `json:"summary,omitempty"`
	WorkStyle  string `json:"workStyle,omitempty"`
	Edges      string `json:"edges,omitempty"`
	CVPath     string `json:"cvPath"` // Path to the cv.md file
}

// WorkerRef is a simple reference to an agent
type WorkerRef struct {
	Name string `json:"name"`
}

// WorkerList tracks which denizens are working on a project
type WorkerList struct {
	Orchestrator *WorkerRef  `json:"orchestrator,omitempty"` // Selected orchestrator
	Workers      []WorkerRef `json:"workers,omitempty"`      // Worker denizens
	UpdatedAt    string      `json:"updatedAt"`              // ISO timestamp
}

// legacyWorkerList represents the historical structure where orchestrator/workers were plain strings
type legacyWorkerList struct {
	Orchestrator string   `json:"orchestrator"`
	Workers      []string `json:"workers"`
	UpdatedAt    string   `json:"updatedAt"`
}

type openCodeConfig struct {
	Schema       string                   `json:"$schema"`
	DefaultAgent string                   `json:"default_agent,omitempty"`
	Plugin       []string                 `json:"plugin,omitempty"`
	Agents       map[string]openCodeAgent `json:"agent,omitempty"`
}

type openCodeAgent struct {
	Description  string   `json:"description,omitempty"`
	Mode         string   `json:"mode,omitempty"`
	Prompt       string   `json:"prompt"`
	Instructions []string `json:"instructions,omitempty"`
}

// WorkCompleteMsg is sent when OpenCode finishes successfully
type WorkCompleteMsg struct {
	Agents []Agent
}

// WorkErrorMsg is sent when something goes wrong
type WorkErrorMsg struct {
	Err error
}

// Orchestrator manages the OpenCode process
type Orchestrator struct {
	config     *config.Config
	windowName string
}

const (
	opencodeSchemaURL      = "https://opencode.ai/config.json"
	generatedConfigComment = "// Generated by lattice-cli"
)

var defaultOpencodePlugins = []string{"opencode-worktree"}

func (o *Orchestrator) currentOrchestratorAgent() string {
	if o == nil || o.config == nil {
		return ""
	}
	workerList := o.loadWorkerList(o.config.WorkerListPath())
	if workerList.Orchestrator != nil {
		return strings.TrimSpace(workerList.Orchestrator.Name)
	}
	return ""
}

// New creates a new Orchestrator
func New(cfg *config.Config) *Orchestrator {
	return &Orchestrator{
		config:     cfg,
		windowName: "opencode-worker",
	}
}

// StartWork returns a tea.Cmd that loads available denizen CVs.
// This runs asynchronously and sends a message when done.
func (o *Orchestrator) StartWork() tea.Cmd {
	return func() tea.Msg {
		// Load denizen CVs directly from the Lattice communities
		agents, err := o.LoadDenizenCVs()
		if err != nil {
			return WorkErrorMsg{Err: fmt.Errorf("failed to load denizen CVs: %w", err)}
		}

		if len(agents) == 0 {
			return WorkErrorMsg{Err: fmt.Errorf("no denizens with CVs found in communities")}
		}

		return WorkCompleteMsg{Agents: agents}
	}
}

// createTmuxWindow creates a new tmux window for our worker
func (o *Orchestrator) createTmuxWindow(name string) error {
	if name == "" {
		name = o.windowName
	}
	cmd := exec.Command("tmux", "new-window", "-n", name)
	return cmd.Run()
}

func (o *Orchestrator) createTmuxWindowInDir(name, dir string) error {
	if dir == "" {
		return o.createTmuxWindow(name)
	}
	cmd := exec.Command("tmux", "new-window", "-n", name, "-c", dir)
	return cmd.Run()
}

// killTmuxWindow closes the worker window
func (o *Orchestrator) killTmuxWindow(name string) error {
	if name == "" {
		name = o.windowName
	}
	cmd := exec.Command("tmux", "kill-window", "-t", name)
	if err := cmd.Run(); err != nil {
		return err
	}
	return nil
}

// runOpenCode sends the OpenCode command to the tmux window and falls back to the
// selected orchestrator agent if agentName is empty.
func (o *Orchestrator) runOpenCode(prompt string, windowName string, agentName string) error {
	return o.runOpenCodeWithOptions(prompt, windowName, agentName, true)
}

// runOpenCodeNoDefault sends the OpenCode command without selecting any agent.
func (o *Orchestrator) runOpenCodeNoDefault(prompt string, windowName string) error {
	return o.runOpenCodeWithOptions(prompt, windowName, "", false)
}

func (o *Orchestrator) runOpenCodeWithOptions(prompt string, windowName string, agentName string, allowFallback bool) error {
	if windowName == "" {
		windowName = o.windowName
	}
	escapedPrompt := strings.ReplaceAll(prompt, `"`, `\"`)
	escapedPrompt = strings.ReplaceAll(escapedPrompt, "\n", " ")
	args := []string{"opencode"}
	normalizedAgent := strings.TrimSpace(agentName)
	if normalizedAgent == "" && allowFallback {
		normalizedAgent = o.currentOrchestratorAgent()
	}
	if normalizedAgent != "" {
		slug := slugifyToken(normalizedAgent)
		if slug != "" {
			escapedAgent := strings.ReplaceAll(slug, `"`, `\"`)
			args = append(args, fmt.Sprintf(`--agent "%s"`, escapedAgent))
		}
	}
	args = append(args, fmt.Sprintf(`--prompt "%s"`, escapedPrompt))
	opencodeCmd := strings.Join(args, " ")
	cmd := exec.Command("tmux", "send-keys", "-t", windowName, opencodeCmd, "Enter")
	return cmd.Run()
}

func (o *Orchestrator) restartInitialPromptWithCycle(cycle int) error {
	prompt := o.initialCyclePrompt(cycle)
	_ = o.killTmuxWindow(o.windowName)
	if err := o.createTmuxWindow(o.windowName); err != nil {
		return err
	}
	return o.runOpenCode(prompt, o.windowName, "")
}

func (o *Orchestrator) restartInitialPrompt() error {
	cycle, err := o.currentCycleNumber()
	if err != nil {
		return err
	}
	return o.restartInitialPromptWithCycle(cycle)
}

func (o *Orchestrator) initialCyclePrompt(cycle int) string {
	agentManual := filepath.Join(o.config.ProjectDir, "AGENTS.md")
	return fmt.Sprintf(
		"Cycle %d is ready. Get started on the work that is assigned to you. Use bd for issue tracking. Only do the work that is assigned to you in beads (bd). Read the latest instructions in %s. When the next pre-cycle assigns new worktrees, load each WORKTREE.md into your context, log unrelated bugs under '# unrelated bugs', and if you fail three times on a bead add an entry under '# need help' before unassigning it. Keep the worktree clean, land the plane at the end of every session, and wait here for the orchestrator to assign fresh beads.",
		cycle,
		agentManual,
	)
}

// waitForCompletion polls for the DONE file that signals OpenCode finished
func (o *Orchestrator) waitForCompletion() error {
	doneFile := filepath.Join(o.config.CVsDir(), "DONE")

	// Poll every second for up to 5 minutes
	timeout := time.After(5 * time.Minute)
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-timeout:
			return fmt.Errorf("timed out waiting for OpenCode to complete")

		case <-ticker.C:
			// Check if DONE file exists
			if _, err := os.Stat(doneFile); err == nil {
				// DONE file exists - clean it up and return
				os.Remove(doneFile)
				return nil
			}
		}
	}
}

// LoadDenizenCVs reads cv.md files from all communities in the Lattice
func (o *Orchestrator) LoadDenizenCVs() ([]Agent, error) {
	communitiesDir := o.config.CommunitiesDir()

	var agents []Agent

	communities, err := os.ReadDir(communitiesDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read communities dir: %w", err)
	}

	for _, entry := range communities {
		if !entry.IsDir() {
			continue
		}

		communityRoot := filepath.Join(communitiesDir, entry.Name())
		cfg, err := community.Load(communityRoot)
		if err != nil {
			continue
		}

		communityName := strings.TrimSpace(cfg.Config.Name)
		if communityName == "" {
			communityName = entry.Name()
		}

		denizensDir := cfg.CVsPath()
		denizens, err := os.ReadDir(denizensDir)
		if err != nil {
			continue // Community might not have denizens yet
		}

		for _, denizen := range denizens {
			if !denizen.IsDir() {
				continue // Skip files like denizen-file-structure.md
			}

			cvPath := filepath.Join(denizensDir, denizen.Name(), "cv.md")
			agent, err := o.parseCVFile(cvPath, communityName)
			if err != nil {
				continue // Skip denizens without CVs
			}

			agents = append(agents, agent)
		}
	}

	return agents, nil
}

// parseCVFile parses a cv.md file into an Agent struct
func (o *Orchestrator) parseCVFile(cvPath string, communityName string) (Agent, error) {
	data, err := os.ReadFile(cvPath)
	if err != nil {
		return Agent{}, err
	}

	content := string(data)
	agent := Agent{
		CVPath:    cvPath,
		Community: communityName,
	}

	// Parse YAML frontmatter (between --- markers)
	if strings.HasPrefix(content, "---") {
		parts := strings.SplitN(content, "---", 3)
		if len(parts) >= 3 {
			frontmatter := parts[1]
			body := parts[2]

			// Parse frontmatter fields
			for _, line := range strings.Split(frontmatter, "\n") {
				line = strings.TrimSpace(line)
				if strings.HasPrefix(line, "name:") {
					agent.Name = strings.TrimSpace(strings.TrimPrefix(line, "name:"))
				} else if strings.HasPrefix(line, "byline:") {
					agent.Byline = strings.TrimSpace(strings.TrimPrefix(line, "byline:"))
				} else if strings.HasPrefix(line, "community:") {
					agent.Community = strings.TrimSpace(strings.TrimPrefix(line, "community:"))
				}
			}

			// Parse body for attributes
			for _, line := range strings.Split(body, "\n") {
				line = strings.TrimSpace(line)
				if strings.HasPrefix(line, "precision:") {
					fmt.Sscanf(line, "precision: %d", &agent.Precision)
				} else if strings.HasPrefix(line, "autonomy:") {
					fmt.Sscanf(line, "autonomy: %d", &agent.Autonomy)
				} else if strings.HasPrefix(line, "experience:") {
					fmt.Sscanf(line, "experience: %d", &agent.Experience)
				}
			}

			// Extract Summary section
			agent.Summary = extractSection(body, "# Summary")
			agent.WorkStyle = extractSection(body, "# Working Style")
			agent.Edges = extractSection(body, "# Edges")
		}
	}

	if agent.Name == "" {
		return Agent{}, fmt.Errorf("no name found in CV")
	}

	return agent, nil
}

// extractSection extracts content after a markdown heading until the next heading
func extractSection(content string, heading string) string {
	idx := strings.Index(content, heading)
	if idx == -1 {
		return ""
	}

	// Start after the heading line
	start := idx + len(heading)
	rest := content[start:]

	// Find next heading
	lines := strings.Split(rest, "\n")
	var result []string
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "#") {
			break
		}
		if trimmed != "" {
			result = append(result, trimmed)
		}
	}

	return strings.Join(result, " ")
}

func (o *Orchestrator) loadWorkerList(workerListPath string) WorkerList {
	workerList := WorkerList{
		Workers: []WorkerRef{},
	}

	data, err := os.ReadFile(workerListPath)
	if err != nil {
		return workerList
	}

	if err := json.Unmarshal(data, &workerList); err == nil {
		if workerList.Workers == nil {
			workerList.Workers = []WorkerRef{}
		}
		return workerList
	}

	var legacy legacyWorkerList
	if err := json.Unmarshal(data, &legacy); err == nil {
		if legacy.Orchestrator != "" {
			workerList.Orchestrator = &WorkerRef{Name: legacy.Orchestrator}
		}
		for _, w := range legacy.Workers {
			workerList.Workers = append(workerList.Workers, WorkerRef{Name: w})
		}
		workerList.UpdatedAt = legacy.UpdatedAt
	}

	if workerList.Workers == nil {
		workerList.Workers = []WorkerRef{}
	}

	return workerList
}

// CurrentWorkerList returns the worker list as recorded on disk.
func (o *Orchestrator) CurrentWorkerList() WorkerList {
	if o == nil || o.config == nil {
		return WorkerList{Workers: []WorkerRef{}}
	}
	return o.loadWorkerList(o.config.WorkerListPath())
}

// LoadProjectAgents returns the generated project agents available to the orchestrator.
func (o *Orchestrator) LoadProjectAgents() ([]ProjectAgent, error) {
	if o == nil {
		return nil, fmt.Errorf("orchestrator not initialized")
	}
	return o.loadProjectAgents()
}

// RunStakeholderAudit launches a tmux worker that reviews the project from the
// perspective of the provided role and writes the audit markdown file.
func (o *Orchestrator) RunStakeholderAudit(role string, agent ProjectAgent, auditPath string, projectDesc string) error {
	if o == nil {
		return fmt.Errorf("orchestrator not initialized")
	}
	if strings.TrimSpace(role) == "" {
		return fmt.Errorf("stakeholder role is required")
	}
	if strings.TrimSpace(agent.Name) == "" {
		return fmt.Errorf("stakeholder agent missing name")
	}
	if err := os.MkdirAll(filepath.Dir(auditPath), 0755); err != nil {
		return fmt.Errorf("failed to prepare audit path: %w", err)
	}
	window := fmt.Sprintf("audit-%s-%d", slugifyToken(role), time.Now().UnixNano())
	if err := o.createTmuxWindow(window); err != nil {
		return fmt.Errorf("failed to launch tmux window: %w", err)
	}
	defer o.killTmuxWindow(window)
	prompt := o.buildStakeholderAuditPrompt(role, agent, auditPath, projectDesc)
	if err := o.runOpenCode(prompt, window, agent.Name); err != nil {
		return fmt.Errorf("failed to start audit session: %w", err)
	}
	return o.waitForFile(auditPath, 5*time.Minute)
}

// RunAuditSynthesis asks the orchestrator agent to read all audit files and
// convert actionable feedback into beads. A synthesis file path is returned to
// indicate completion.
func (o *Orchestrator) RunAuditSynthesis(auditDir string, projectDesc string) (string, error) {
	if o == nil {
		return "", fmt.Errorf("orchestrator not initialized")
	}
	if err := os.MkdirAll(auditDir, 0755); err != nil {
		return "", fmt.Errorf("failed to prepare audit dir: %w", err)
	}
	summaryPath := filepath.Join(auditDir, "SYNTHESIS.md")
	window := fmt.Sprintf("audit-synthesis-%d", time.Now().UnixNano())
	if err := o.createTmuxWindow(window); err != nil {
		return "", fmt.Errorf("failed to launch tmux window: %w", err)
	}
	defer o.killTmuxWindow(window)
	prompt := o.buildAuditSynthesisPrompt(auditDir, summaryPath, projectDesc)
	if err := o.runOpenCode(prompt, window, ""); err != nil {
		return "", fmt.Errorf("failed to start audit synthesis: %w", err)
	}
	if err := o.waitForFile(summaryPath, 5*time.Minute); err != nil {
		return "", err
	}
	return summaryPath, nil
}

// LaunchManualReviewSession opens a tmux window primed for a human-guided
// manual review conversation and returns the window name for later cleanup.
func (o *Orchestrator) LaunchManualReviewSession(projectDesc string) (string, error) {
	if o == nil {
		return "", fmt.Errorf("orchestrator not initialized")
	}
	window := fmt.Sprintf("manual-review-%d", time.Now().UnixNano())
	if err := o.createTmuxWindow(window); err != nil {
		return "", fmt.Errorf("failed to launch manual review window: %w", err)
	}
	prompt := o.buildManualReviewPrompt(projectDesc)
	if err := o.runOpenCode(prompt, window, ""); err != nil {
		o.killTmuxWindow(window)
		return "", fmt.Errorf("failed to start manual review session: %w", err)
	}
	return window, nil
}

// CloseWindow forcefully terminates a tmux window created by the orchestrator.
func (o *Orchestrator) CloseWindow(name string) error {
	if o == nil || strings.TrimSpace(name) == "" {
		return nil
	}
	return o.killTmuxWindow(name)
}

func (o *Orchestrator) buildStakeholderAuditPrompt(role string, agent ProjectAgent, auditPath string, projectDesc string) string {
	var b strings.Builder
	projectDesc = strings.TrimSpace(projectDesc)
	if projectDesc == "" {
		projectDesc = "this repository"
	}
	fmt.Fprintf(&b, "You are acting as the %s for %s.\n", role, projectDesc)
	b.WriteString("Review the recently completed work with intent to ship.\n")
	b.WriteString("Inspect code, docs, beads, and tests. Walk paths a real stakeholder cares about.\n")
	b.WriteString("Highlight concrete bugs, regressions, missing coverage, polish opportunities, and wins.\n")
	b.WriteString("Anchor every issue in facts (files, commands, logs). Offer fixes or next steps.\n")
	b.WriteString("If nothing needs attention, explicitly record that.\n\n")
	if agent.Path != "" {
		fmt.Fprintf(&b, "Your agent profile is at %s. Load it for voice and instincts.\n", agent.Path)
	}
	fmt.Fprintf(&b, "Write your findings to %s in Markdown with sections: Overview, Strengths, Risks, Recommendations.\n", auditPath)
	b.WriteString("Always end with a short checklist of next actions.")
	b.WriteString(" If there are zero findings, still write a brief note such as 'LGTM'.\n")
	b.WriteString("Once the file exists and feels solid, exit.\n")
	return b.String()
}

func (o *Orchestrator) buildAuditSynthesisPrompt(auditDir, summaryPath, projectDesc string) string {
	var b strings.Builder
	projectDesc = strings.TrimSpace(projectDesc)
	if projectDesc == "" {
		projectDesc = "the current project"
	}
	fmt.Fprintf(&b, "All stakeholder audits live under %s for %s.\n", auditDir, projectDesc)
	b.WriteString("1. Read each <ROLE>-audit.md file and list the actionable items.\n")
	b.WriteString("2. For every concrete issue, run `bd create` (or `bd add`) to make a bead with a meaningful title and crisp description referencing the audit.\n")
	b.WriteString("3. Group related fixes when appropriate, but do not skip anything material.\n")
	b.WriteString("4. Respond to praise or 'all good' notes by logging that no bead was needed.\n")
	b.WriteString("5. Log a summary of what you created in ")
	b.WriteString(summaryPath)
	b.WriteString(" with sections: Inputs, Beads Created (include IDs), Follow-ups.\n")
	b.WriteString("6. Only finish when every audit has been processed, the summary file exists, and bd ready shows the new beads queued.\n")
	return b.String()
}

func (o *Orchestrator) buildManualReviewPrompt(projectDesc string) string {
	projectDesc = strings.TrimSpace(projectDesc)
	if projectDesc == "" {
		projectDesc = "this project"
	}
	var b strings.Builder
	fmt.Fprintf(&b, "You are the orchestrator guiding a manual review for %s.\n", projectDesc)
	b.WriteString("The human user will type into this chat with questions and bug reports.\n")
	b.WriteString("Your responsibilities:\n")
	b.WriteString("- Triage every note, ask clarifying questions, and confirm reproduction steps.\n")
	b.WriteString("- When a real bug or task appears, immediately create a bead via `bd create` with a descriptive title + summary.\n")
	b.WriteString("- If the fix is urgent, spin up a focused agent (spawn another opencode worker) to tackle it, otherwise leave it in beads.\n")
	b.WriteString("- Keep the user informed until they say everything looks good.\n")
	b.WriteString("Log what happened directly into the chat or into bead descriptions. Stay present until dismissed.")
	return b.String()
}

// GenerateAgentFile runs the create-agent-file skill to write ./lattice/agents/<role>/AGENT.md
func (o *Orchestrator) GenerateAgentFile(agent Agent, role, roleContext string) (string, error) {
	sourceDir := filepath.Join(o.config.CVsDir(), agent.Community, agent.Name)
	if _, err := os.Stat(sourceDir); err != nil {
		return "", fmt.Errorf("orchestrator source files missing for %s: %w", agent.Name, err)
	}

	roleFolder := filepath.Join(o.config.AgentsDir(), role)
	if err := os.MkdirAll(roleFolder, 0755); err != nil {
		return "", fmt.Errorf("failed to prepare agent folder: %w", err)
	}

	targetFile := filepath.Join(roleFolder, "AGENT.md")

	if err := o.runAgentSkill(agent, role, roleContext, sourceDir, targetFile, false); err != nil {
		if err := o.runAgentSkill(agent, role, roleContext, sourceDir, targetFile, true); err != nil {
			return "", err
		}
	}

	if err := o.notifyTmux(fmt.Sprintf("Agent file ready for %s â†’ %s", agent.Name, targetFile)); err != nil {
		return targetFile, fmt.Errorf("tmux notification failed: %w", err)
	}

	return targetFile, nil
}

func (o *Orchestrator) runAgentSkill(agent Agent, role, roleContext, sourceDir, targetFile string, strict bool) error {
	_ = os.Remove(targetFile)
	skillPath, err := skills.Ensure(o.config.SkillsDir(), skills.CreateAgentFile)
	if err != nil {
		return err
	}
	prompt := o.buildAgentSkillPrompt(agent, role, roleContext, sourceDir, targetFile, skillPath, strict)
	windowName := fmt.Sprintf("agent-file-%d", time.Now().UnixNano())
	if err := o.createTmuxWindow(windowName); err != nil {
		return fmt.Errorf("failed to start tmux window for agent file: %w", err)
	}
	defer o.killTmuxWindow(windowName)

	if err := o.runOpenCodeNoDefault(prompt, windowName); err != nil {
		return fmt.Errorf("failed to send OpenCode prompt: %w", err)
	}

	return o.waitForFile(targetFile, 5*time.Minute)
}

func (o *Orchestrator) buildAgentSkillPrompt(agent Agent, role, roleContext, sourceDir, targetFile, skillPath string, strict bool) string {
	var b strings.Builder
	fmt.Fprintf(&b, "You are running inside a tmux worker window. Load the skill definition at %s and execute it. ", skillPath)
	fmt.Fprintf(&b, "This brief will live under lattice/agents/%s. ", role)
	fmt.Fprintf(&b, "Inputs: identity_dir=%s, output_path=%s, role_context=%s. ", sourceDir, targetFile, roleContext)
	fmt.Fprintf(&b, "Identity materials live in %s. Write the AGENT.md file to %s and record every Markdown source you draw from. ", sourceDir, targetFile)
	b.WriteString("Use the skill's provenance frontmatter requirements and include the completion hook by emitting the [tmux-hook] line once finished. ")
	if strict {
		b.WriteString("This is a retry because the destination file was missing. You are NOT done until the AGENT.md file exists at the destination with the latest timestamp. ")
	}
	b.WriteString("Double-check that the Sources section lists every document before signalling completion.")
	return b.String()
}

func (o *Orchestrator) waitForFile(path string, timeout time.Duration) error {
	deadline := time.After(timeout)
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-deadline:
			return fmt.Errorf("timed out waiting for %s", path)
		case <-ticker.C:
			info, err := os.Stat(path)
			if err == nil && info.Size() > 0 {
				return nil
			}
		}
	}
}

func (o *Orchestrator) notifyTmux(message string) error {
	cmd := exec.Command("tmux", "display-message", message)
	return cmd.Run()
}

// ApplyOrchestratorSelection persists the orchestrator, generates an agent profile, and refreshes opencode config.
func (o *Orchestrator) ApplyOrchestratorSelection(agent Agent) error {
	if err := o.SetOrchestrator(agent); err != nil {
		return err
	}
	if err := o.ensureOrchestratorAgentFile(agent); err != nil {
		return err
	}
	return o.RefreshOpenCodeConfig()
}

// SetOrchestrator writes or updates the worker-list.json with the selected orchestrator
func (o *Orchestrator) SetOrchestrator(agent Agent) error {
	workerListPath := o.config.WorkerListPath()

	// Try to load existing worker list
	workerList := o.loadWorkerList(workerListPath)

	// Update orchestrator metadata
	workerList.Orchestrator = &WorkerRef{Name: agent.Name}
	workerList.UpdatedAt = time.Now().UTC().Format(time.RFC3339)

	if err := o.copyOrchestratorFiles(agent); err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(workerListPath), 0755); err != nil {
		return fmt.Errorf("failed to prepare state directory: %w", err)
	}

	// Write back
	data, err := json.MarshalIndent(workerList, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal worker list: %w", err)
	}

	if err := os.WriteFile(workerListPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write worker list: %w", err)
	}

	return nil
}

func (o *Orchestrator) ensureOrchestratorAgentFile(agent Agent) error {
	if strings.TrimSpace(agent.Name) == "" {
		return fmt.Errorf("orchestrator agent name is required")
	}
	rolePath := filepath.Join("orchestrator", slugifyToken(agent.Name))
	_, err := o.GenerateAgentFile(agent, rolePath, "orchestrator")
	return err
}

// AddWorker adds a worker denizen to the worker list
func (o *Orchestrator) AddWorker(agentName string) error {
	workerListPath := o.config.WorkerListPath()

	// Load existing worker list
	workerList := o.loadWorkerList(workerListPath)

	// Check if already in list
	for _, w := range workerList.Workers {
		if w.Name == agentName {
			return nil // Already added
		}
	}

	// Add worker
	workerList.Workers = append(workerList.Workers, WorkerRef{Name: agentName})
	workerList.UpdatedAt = time.Now().UTC().Format(time.RFC3339)

	if err := os.MkdirAll(filepath.Dir(workerListPath), 0755); err != nil {
		return fmt.Errorf("failed to prepare state directory: %w", err)
	}

	// Write back
	data, err := json.MarshalIndent(workerList, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal worker list: %w", err)
	}

	return os.WriteFile(workerListPath, data, 0644)
}

// RefreshOpenCodeConfig writes opencode.jsonc describing project agents and plugins.
func (o *Orchestrator) RefreshOpenCodeConfig() error {
	if o == nil || o.config == nil {
		return fmt.Errorf("orchestrator is not initialized")
	}
	agents, err := o.loadProjectAgents()
	if err != nil {
		return err
	}
	if len(agents) == 0 {
		return fmt.Errorf("no agent files found in %s", o.config.AgentsDir())
	}
	plugins := make([]string, len(defaultOpencodePlugins))
	copy(plugins, defaultOpencodePlugins)
	cfg := openCodeConfig{
		Schema: opencodeSchemaURL,
		Plugin: plugins,
		Agents: make(map[string]openCodeAgent),
	}
	preferred := slugifyToken(o.currentOrchestratorAgent())
	for _, agent := range agents {
		slug := slugifyToken(agent.Name)
		if slug == "" {
			continue
		}
		entry := openCodeAgent{
			Description: strings.TrimSpace(agent.Summary),
			Mode:        "primary",
			Prompt:      o.relativeFileRef(agent.Path),
		}
		if entry.Prompt == "" {
			continue
		}
		if entry.Description == "" {
			if agent.Role != "" {
				entry.Description = fmt.Sprintf("%s agent", agent.Role)
			} else {
				entry.Description = fmt.Sprintf("Agent %s", agent.Name)
			}
		}
		if agent.Memory != "" {
			rel := o.relativeFileRef(agent.Memory)
			if rel != "" {
				entry.Instructions = []string{rel}
			}
		}
		cfg.Agents[slug] = entry
		if cfg.DefaultAgent == "" && preferred != "" && slug == preferred {
			cfg.DefaultAgent = slug
		}
	}
	if cfg.DefaultAgent == "" {
		for _, agent := range agents {
			if strings.Contains(strings.ToLower(agent.Role), "orchestrator") {
				cfg.DefaultAgent = slugifyToken(agent.Name)
				break
			}
		}
	}
	if cfg.DefaultAgent == "" {
		for slug := range cfg.Agents {
			cfg.DefaultAgent = slug
			break
		}
	}
	return o.writeOpenCodeConfig(cfg)
}

func (o *Orchestrator) relativeFileRef(path string) string {
	if strings.TrimSpace(path) == "" {
		return ""
	}
	rel, err := filepath.Rel(o.config.ProjectDir, path)
	if err != nil {
		rel = path
	}
	return fmt.Sprintf("{file:%s}", filepath.ToSlash(rel))
}

func (o *Orchestrator) writeOpenCodeConfig(cfg openCodeConfig) error {
	if err := o.backupExistingOpencodeConfig(); err != nil {
		return err
	}
	data, err := json.MarshalIndent(cfg, "", "  ")
	if err != nil {
		return err
	}
	var b strings.Builder
	b.WriteString(generatedConfigComment)
	b.WriteByte('\n')
	b.Write(data)
	b.WriteByte('\n')
	configPath := filepath.Join(o.config.ProjectDir, "opencode.jsonc")
	return os.WriteFile(configPath, []byte(b.String()), 0644)
}

func (o *Orchestrator) backupExistingOpencodeConfig() error {
	projectDir := o.config.ProjectDir
	type candidate struct {
		source          string
		backup          string
		skipIfGenerated bool
	}
	candidates := []candidate{
		{source: filepath.Join(projectDir, "opencode.json"), backup: filepath.Join(projectDir, "opencode.old.json")},
		{source: filepath.Join(projectDir, "opencode.jsonc"), backup: filepath.Join(projectDir, "opencode.old.jsonc"), skipIfGenerated: true},
	}
	for _, cand := range candidates {
		if _, err := os.Stat(cand.source); err != nil {
			continue
		}
		if cand.skipIfGenerated {
			data, err := os.ReadFile(cand.source)
			if err == nil && strings.Contains(string(data), generatedConfigComment) {
				continue
			}
		}
		if _, err := os.Stat(cand.backup); err == nil {
			continue
		}
		if err := os.Rename(cand.source, cand.backup); err != nil {
			return fmt.Errorf("failed to back up %s: %w", cand.source, err)
		}
	}
	return nil
}

// copyOrchestratorFiles copies the selected agent's files into the calling project
func (o *Orchestrator) copyOrchestratorFiles(agent Agent) error {
	if agent.CVPath == "" {
		return fmt.Errorf("agent %s is missing a CV path", agent.Name)
	}

	sourceDir := filepath.Dir(agent.CVPath)
	if _, err := os.Stat(sourceDir); err != nil {
		return fmt.Errorf("unable to locate orchestrator files for %s: %w", agent.Name, err)
	}

	destDir := filepath.Join(o.config.CVsDir(), agent.Community, agent.Name)
	if err := os.RemoveAll(destDir); err != nil {
		return fmt.Errorf("failed to reset orchestrator directory: %w", err)
	}

	if err := copyDir(sourceDir, destDir); err != nil {
		return fmt.Errorf("failed to copy orchestrator files: %w", err)
	}

	return nil
}

func copyDir(src, dst string) error {
	return filepath.WalkDir(src, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		rel, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}

		if d.IsDir() {
			if rel == "." {
				return os.MkdirAll(dst, 0755)
			}
			return os.MkdirAll(filepath.Join(dst, rel), 0755)
		}

		info, err := d.Info()
		if err != nil {
			return err
		}

		return copyFile(path, filepath.Join(dst, rel), info.Mode())
	})
}

func copyFile(src, dst string, mode fs.FileMode) error {
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return err
	}

	in, err := os.Open(src)
	if err != nil {
		return err
	}
	defer in.Close()

	out, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode.Perm())
	if err != nil {
		return err
	}
	defer out.Close()

	if _, err := io.Copy(out, in); err != nil {
		return err
	}

	return nil
}
