// internal/modes/orchestrator_release/orchestrator_release.go
//
// Orchestrator Release mode handles releasing the orchestrator after all work is done.
// Input: .lattice/workflow/release/.cleanup-done
// Output: .lattice/workflow/release/.orchestrator-released

package orchestrator_release

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/yourusername/lattice/internal/modes"
	"github.com/yourusername/lattice/internal/workflow"
)

const generatedConfigHeader = "// Generated by lattice-cli"

// Mode handles the orchestrator release phase
type Mode struct {
	modes.BaseMode
	width  int
	height int
}

// New creates a new Orchestrator Release mode
func New() *Mode {
	return &Mode{
		BaseMode: modes.NewBaseMode("Orchestrator Release", workflow.PhaseOrchestratorRelease),
	}
}

// Init initializes the orchestrator release mode
func (m *Mode) Init(ctx *modes.ModeContext) tea.Cmd {
	m.SetContext(ctx)

	// Check if orchestrator already released
	wf := ctx.Workflow
	releasedMarker := filepath.Join(wf.ReleaseDir(), workflow.MarkerOrchestratorReleased)
	if fileExists(releasedMarker) {
		m.SetComplete(true)
		m.SetStatusMsg("Orchestrator already released, workflow complete!")
		return func() tea.Msg {
			return modes.ModeCompleteMsg{NextPhase: workflow.PhaseComplete}
		}
	}

	m.SetStatusMsg("Releasing orchestrator...")
	return m.releaseOrchestrator()
}

// Update handles messages for the orchestrator release mode
func (m *Mode) Update(msg tea.Msg) (modes.Mode, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		return m, nil

	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c":
			return m, tea.Quit
		case "esc":
			return m, func() tea.Msg {
				return modes.ModeErrorMsg{Error: fmt.Errorf("orchestrator release cancelled")}
			}
		}

	case orchestratorReleasedMsg:
		m.SetComplete(true)
		m.SetStatusMsg("Commission complete! Orchestrator released.")
		return m, func() tea.Msg {
			return modes.ModeCompleteMsg{NextPhase: workflow.PhaseComplete}
		}

	case modes.ModeErrorMsg:
		m.SetStatusMsg(fmt.Sprintf("Error: %v", msg.Error))
		return m, nil
	}

	return m, nil
}

// View renders the orchestrator release mode
func (m *Mode) View() string {
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#2ECC71")).
		Padding(1)

	statusStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#888888")).
		MarginTop(1)

	content := titleStyle.Render(`
  âœ… RELEASING ORCHESTRATOR

  The final release:
  1. Archive orchestrator's work summary
  2. Generate commission report
  3. Mark workflow as complete

  Waiting for release to complete...

  Press ESC to cancel.
`)

	return fmt.Sprintf("%s\n%s", content, statusStyle.Render(m.StatusMsg()))
}

// Message types
type orchestratorReleasedMsg struct{}

// releaseOrchestrator performs the orchestrator release
func (m *Mode) releaseOrchestrator() tea.Cmd {
	return func() tea.Msg {
		ctx := m.Context()
		if ctx == nil {
			return modes.ModeErrorMsg{Error: fmt.Errorf("missing mode context")}
		}

		releaseDir := ctx.Workflow.ReleaseDir()
		if err := os.MkdirAll(releaseDir, 0755); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		if err := resetOpencodeConfig(ctx.Config.ProjectDir); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		if err := removeAgentsDir(ctx.Config.AgentsDir()); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		if err := removeFileIfExists(ctx.Workflow.OrchestratorPath()); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		if err := removeFileIfExists(ctx.Config.WorkerListPath()); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		marker := filepath.Join(releaseDir, workflow.MarkerOrchestratorReleased)
		if err := os.WriteFile(marker, []byte{}, 0644); err != nil {
			return modes.ModeErrorMsg{Error: err}
		}

		return orchestratorReleasedMsg{}
	}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func resetOpencodeConfig(projectDir string) error {
	targets := []struct {
		backup  string
		current string
	}{
		{backup: filepath.Join(projectDir, "opencode.old.jsonc"), current: filepath.Join(projectDir, "opencode.jsonc")},
		{backup: filepath.Join(projectDir, "opencode.old.json"), current: filepath.Join(projectDir, "opencode.json")},
	}
	for _, target := range targets {
		if _, err := os.Stat(target.backup); err == nil {
			if err := os.Remove(target.current); err != nil && !errors.Is(err, os.ErrNotExist) {
				return fmt.Errorf("remove generated config %s: %w", target.current, err)
			}
			if err := os.Rename(target.backup, target.current); err != nil {
				return fmt.Errorf("restore %s: %w", filepath.Base(target.current), err)
			}
			continue
		}
		if isGeneratedConfig(target.current) {
			if err := os.Remove(target.current); err != nil && !errors.Is(err, os.ErrNotExist) {
				return err
			}
		}
	}
	return nil
}

func isGeneratedConfig(path string) bool {
	data, err := os.ReadFile(path)
	if err != nil {
		return false
	}
	return strings.HasPrefix(strings.TrimSpace(string(data)), generatedConfigHeader)
}

func removeAgentsDir(path string) error {
	if err := os.RemoveAll(path); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil
		}
		return fmt.Errorf("remove agents dir: %w", err)
	}
	return nil
}

func removeFileIfExists(path string) error {
	if err := os.Remove(path); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil
		}
		return fmt.Errorf("remove %s: %w", filepath.Base(path), err)
	}
	return nil
}
